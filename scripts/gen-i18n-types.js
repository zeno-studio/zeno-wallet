/**
 * scripts/gen-i18n-types.js
 * 运行：node scripts/gen-i18n-types.js
 *
 * 功能：
 *   1. 扫描 src/locales/*.json
 *   2. 递归遍历所有 key → 打平为 "a.b.c" 格式
 *   3. 生成：
 *        - src/lib/i18n-keys.ts   → type I18nKey = 'a' | 'b.c' | ...
 *        - src/lib/i18n-consts.ts → export const I18N_KEYS = [...] as const
 */

const fs = require('fs');
const path = require('path');

const LOCALES_DIR = path.resolve(__dirname, '../src/locales');
const OUTPUT_KEYS = path.resolve(__dirname, '../src/lib/i18n-keys.ts');
const OUTPUT_CONSTS = path.resolve(__dirname, '../src/lib/i18n-consts.ts');

// 1. 读取所有 .json 文件
const localeFiles = fs.readdirSync(LOCALES_DIR).filter(f => f.endsWith('.json'));
if (localeFiles.length === 0) {
  console.warn('No locale files found in src/locales/');
  process.exit(0);
}

// 2. 收集所有 key（去重）
const allKeys = new Set();

function flatten(obj, prefix = '') {
  for (const [k, v] of Object.entries(obj)) {
    const key = prefix ? `${prefix}.${k}` : k;
    allKeys.add(key);
    if (v && typeof v === 'object' && !Array.isArray(v)) {
      flatten(v, key);
    }
  }
}

for (const file of localeFiles) {
  const content = JSON.parse(fs.readFileSync(path.join(LOCALES_DIR, file), 'utf-8'));
  flatten(content);
}

const keys = Array.from(allKeys).sort();

// 3. 生成 type I18nKey = 'a' | 'b' | ...
const typeContent = `/**
 * AUTO-GENERATED by scripts/gen-i18n-types.js
 * Do not edit manually!
 */
export type I18nKey = ${keys.map(k => `'${k}'`).join(' | ')};\n`;

// 4. 生成 const I18N_KEYS = [...] as const
const constContent = `/**
 * AUTO-GENERATED by scripts/gen-i18n-types.js
 * Do not edit manually!
 */
export const I18N_KEYS = [
  ${keys.map(k => `'${k}'`).join(',\n  ')}
] as const;\n`;

// 5. 写入文件
fs.writeFileSync(OUTPUT_KEYS, typeContent, 'utf-8');
fs.writeFileSync(OUTPUT_CONSTS, constContent, 'utf-8');

console.log(`Generated ${keys.length} i18n keys → i18n-keys.ts & i18n-consts.ts`);